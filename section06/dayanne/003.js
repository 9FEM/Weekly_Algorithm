/*
모든 인형은 1 x 1 크기의 격자 
한 칸을 차지하며 격자의 가장 아래 칸부터 차곡차곡 쌓여 있습니다. 게임 사용자는 크레인을 
좌우로 움직여서 멈춘 위치에서 가장 위에 있는 인형을 집어 올릴 수 있습니다. 집어 올린 인
형은 바구니에 쌓이게 되는 데, 이때 바구니의 가장 아래 칸부터 인형이 순서대로 쌓이게 됩
니다. 만약 같은 모양의 인형 두 개가 바구니에 연속해서 쌓이게 되면 두 인형은 터뜨려지면서 바구
니에서 사라지게 됩니다.

크레인 작동 시 인형이 집어지지 않는 경우는 없으나 만약 인형이 없는 곳에서 크레인을 작동
시키는 경우에는 아무런 일도 일어나지 않습니다. 또한 바구니는 모든 인형이 들어갈 수 있을 
만큼 충분히 크다고 가정합니다. 

게임 화면의 격자의 상태가 담긴 2차원 배열 board와 인형을 집기 위해 크레인을 작동시킨 위
치가 담긴 배열 moves가 매개변수로 주어질 때, 크레인을 모두 작동시킨 후 터트려져 사라진 
인형의 개수를 return 하도록 solution 함수를 완성해주세요.

▣ 입력예제 
[[0,0,0,0,0],
[0,0,1,0,3],
[0,2,5,0,1],
[4,2,4,4,2],
[3,5,1,3,1]] //board 배열
[1,5,3,5,1,2,1,4] //moves 배열

▣ 출력예제
4
*/

function solution(board, moves) {
  const basket = [];
  let count = 0;
  // moves의 길이만큼 작동하는 for문
  for (let x of moves) {
    for (let i = 0; i < board.length; i++) {
      // 0이 아닌 값을 빼내어 바구니에 넣기
      if (board[i][x - 1] === 0) {
        continue;
      } else {
        basket.push(board[i][x - 1]);
        board[i][x - 1] = 0;
        break;
      }
    }

    // 바구니의 길이가 2 이상 && 위에 쌓인 두 인형의 값이 같으면 => 두 인형 모두 제거
    if (basket.length >= 2 && basket[basket.length - 1] === basket[basket.length - 2]) {
      basket.pop();
      basket.pop();
      // 제거한 인형 개수 더하기
      count += 2;
    }
  }
  return count;
}

const boardA = [
  [0, 0, 0, 0, 0],
  [0, 0, 1, 0, 3],
  [0, 2, 5, 0, 1],
  [4, 2, 4, 4, 2],
  [3, 5, 1, 3, 1],
];
const movesA = [1, 5, 3, 5, 1, 2, 1, 4];
console.log(solution(boardA, movesA));
